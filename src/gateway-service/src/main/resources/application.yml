server:
  port: 8080

spring:
  application:
    name: gateway-service
  cloud:
    gateway:
      routes:
        # ----------------------------------------------------------
        # 規則編號：beacon_service_route
        # 職責：將所有發往 /api/beacon/ 的外部請求，安全地路由至 beacon-service
        # ----------------------------------------------------------
        - id: beacon_service_route
          uri: http://beacon-service:8081
          predicates:
            # 斷言：僅當請求路徑匹配 /api/beacon/** 模式時，此規則才生效。
            - Path=/api/beacon/**
          filters:
            # 第一道防線：限流器 (Rate Limiter)
            - name: RateLimiter
              args:
                name: beacon-service-rl
            # 新增第二道防線：艙壁隔離 (Bulkhead)
            - name: Bulkhead
              args:
                name: beacon-service-bh
            # 第三道防線：熔斷器 (Circuit Breaker)
            - name: CircuitBreaker
              args:
                name: beacon-service-cb
                fallbackUri: forward:/fallback/beacon
            - AuthenticationFilter
            - StripPrefix=2

  kafka:
    bootstrap-servers: kafka:9092 # 指向 Docker 內部 DNS
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      # 使用 JSON 序列化器來發送我們的事件對象
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
  rabbitmq:
    host: rabbitmq
    port: 5672
    username: guest
    password: guest
  # ----------------------------------------------------------
  # Redis 配置 (用於分散式 Rate Limiting)
  # ----------------------------------------------------------
  data:
    redis:
      host: redis
      port: 6379
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0

# =================================================================
# ADR-003: JWT 安全密鑰配置
# 該值應在生產環境中，通過環境變量進行覆蓋。
# =================================================================
jwt:
  secret: ${JWT_SECRET_KEY:your-default-super-secret-key-for-local-dev-and-testing}



# ----------------------------------------------------------
# Resilience4j 韌性配置
# ----------------------------------------------------------
resilience4j:
  circuitbreaker:
    instances:
      # 熔斷器實例名稱，必須與上方 filter 中的 name 匹配。
      beacon-service-cb:
        sliding-window-type: COUNT_BASED
        sliding-window-size: 3 # 在 3 次調用中
        failure-rate-threshold: 50 # 失敗率達到 50% (即 2 次失敗)
        wait-duration-in-open-state: 10s
        permitted-number-of-calls-in-half-open-state: 2 # HALF_OPEN 狀態下允許 2 次測試調用


  # ----------------------------------------------------------
  # Rate Limiter 配置 (速率限制器)
  # ----------------------------------------------------------
  ratelimiter:
    instances:
      beacon-service-rl:
        limit-for-period: 20 # 每秒，允許 20 次請求
        limit-refresh-period: 1s
        timeout-duration: 0

  # ----------------------------------------------------------
  # Bulkhead 配置 (艙壁隔離)
  # ----------------------------------------------------------
  bulkhead:
    instances:
      beacon-service-bh:
        max-concurrent-calls: 10 # 最大併發調用數為 10
        max-wait-duration: 0s

#ADR-006: Micrometer 與 Prometheus 生命體徵配置
management:
  endpoints:
    web:
      exposure:
        # 在原有的 health, info 基礎上，新增 prometheus 端點
        # =================================================================
        # == 【【【暴露“韌性”管理端點 】】】 ==
        # =================================================================
        include: health, info, prometheus, circuitbreakers, ratelimiters, bulkheads

# ... (logging config 保持不變) ...
logging:
  level:
    # 將根日誌級別，設置為 INFO
    root: INFO
    # 將我們自己的代碼，設置為 DEBUG，以看到最詳細的日誌
    com.projectdavinci: DEBUG
    # 將 Resilience4j，設置為 DEBUG，以看到所有韌性組件的決策過程
    io.github.resilience4j: DEBUG
    # 將 Spring Cloud Gateway，設置為 TRACE，以看到最底層的路由與過濾器細節
    org.springframework.cloud.gateway: TRACE