# version 屬性已被移除
services:
  gateway-service:
    build:
      context: .
      dockerfile: src/gateway-service/Dockerfile
    ports:
      - "8080:8080"
    container_name: gateway-service
    # ... build, ports, container_name ...
    environment:
      # =================================================================
      # == ADR-008: 激活 OpenTelemetry 時空探針 ==
      # =================================================================
      # 1. 通過 JAVA_TOOL_OPTIONS，將探針附加到 JVM 進程上
      - JAVA_TOOL_OPTIONS=-javaagent:/app/agents/opentelemetry-javaagent.jar
      # 2. 為服務命名，這將成為追蹤數據中的 service.name 標籤
      - OTEL_SERVICE_NAME=gateway-service
      # 3. 告知探針，應將捕獲到的數據，上報給哪個地址
      # 我們，為“語法警察”，提供他所需要的、那個包含了協議的、
      # 語法絕對正確的“外交護照”。
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://tempo:4317

      # 然後，我們，以最高權限，為我們的“外交官”，頒布一道
      # 絕對的、不可違抗的“口頭密令”，命令他，在抵達邊境時，
      # 必須，也只能，說 gRPC 這種語言。
      - OTEL_EXPORTER_OTLP_TRACES_PROTOCOL=grpc
      # 我們，以最高權限，命令“日誌之眼”與“指標之眼”，
      # 保持絕對的、永恆的沉默。
      # 因為，它們的職責，早已由我們更為專業的 Loki 與 Prometheus 所取代。
      - OTEL_LOGS_EXPORTER=none
      - OTEL_METRICS_EXPORTER=none      
      # 4. [關鍵] 告知探針，Kafka 的消息傳播，也應被視為因果鏈路的一部分
      - OTEL_INSTRUMENTATION_KAFKA_CLIENT_PROPAGATION_ENABLED=true
    volumes:
      # 將包含探針的目錄，掛載到容器內部
      - ./agents:/app/agents
    # ... depends_on, restart ...
    depends_on:
      beacon-service:
        condition: service_started
    restart: on-failure

  beacon-service:
    build:
      context: .
      dockerfile: src/beacon-service/Dockerfile
    ports:
      - "8081:8081"
    container_name: beacon-service
    # ... build, ports, container_name ...
    environment:
      # =================================================================
      # == ADR-008: 激活 OpenTelemetry 時空探針 ==
      # =================================================================
      # 1. 通過 JAVA_TOOL_OPTIONS，將探針附加到 JVM 進程上
      - JAVA_TOOL_OPTIONS=-javaagent:/app/agents/opentelemetry-javaagent.jar
      # 2. 為服務命名，這將成為追蹤數據中的 service.name 標籤
      - OTEL_SERVICE_NAME=beacon-service
      # 3. 告知探針，應將捕獲到的數據，上報給哪個地址
      # 我們，為“語法警察”，提供他所需要的、那個包含了協議的、
      # 語法絕對正確的“外交護照”。
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://tempo:4317

      # 然後，我們，以最高權限，為我們的“外交官”，頒布一道
      # 絕對的、不可違抗的“口頭密令”，命令他，在抵達邊境時，
      # 必須，也只能，說 gRPC 這種語言。
      - OTEL_EXPORTER_OTLP_TRACES_PROTOCOL=grpc
      # 我們，以最高權限，命令“日誌之眼”與“指標之眼”，
      # 保持絕對的、永恆的沉默。
      # 因為，它們的職責，早已由我們更為專業的 Loki 與 Prometheus 所取代。
      - OTEL_LOGS_EXPORTER=none
      - OTEL_METRICS_EXPORTER=none      
      # 4. [關鍵] 告知探針，Kafka 的消息傳播，也應被視為因果鏈路的一部分
      - OTEL_INSTRUMENTATION_KAFKA_CLIENT_PROPAGATION_ENABLED=true
    volumes:
      # 將包含探針的目錄，掛載到容器內部
      - ./agents:/app/agents
    # ... depends_on, restart ...
    depends_on:
      kafka:
        condition: service_healthy
      kafka-init-topics:
        condition: service_completed_successfully
    restart: on-failure

  kafka:
    image: bitnamilegacy/kafka:3.3.2
    container_name: kafka-broker
    ports:
      - "9092:9092"
    environment:
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
      - KAFKA_CFG_BROKER_ID=0
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
    healthcheck:
      test: ["CMD-SHELL", "kafka-topics.sh --bootstrap-server localhost:9092 --list"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
# ... existing kafka service ...
  kafka-init-topics:
    image: bitnamilegacy/kafka:3.3.2
    depends_on:
      kafka:
        condition: service_healthy
    # =================================================================
    # ==      【【【 唯一的、最終的、純淨的作戰手冊 】】】      ==
    # =================================================================
    # 我們，將那個幽靈的、不存在的、也根本不必要的“cub”指令，徹底驅逐。
    # “depends_on”的秩序，早已確保了，當這位“立法者”被喚醒時，
    # Kafka，早已準備就緒。
    command: >
      bash -c "
        echo 'Kafka broker is ready, proceeding with topic creation...' &&
        kafka-topics.sh --create --topic topic.beacon.events --partitions 1 --replication-factor 1 --if-not-exists --bootstrap-server kafka:9092 &&
        echo 'Topic topic.beacon.events created successfully (if not exists).'
      "

  # =================================================================
  # == ADR-006: 部署 Prometheus 監控哨站 ==
  # =================================================================
  prometheus:
    image: prom/prometheus:v2.53.0 # 使用一個明確的版本以保證可複現性
    container_name: prometheus-server
    ports:
      - "9090:9090"
    volumes:
      - ./config/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
    command: --config.file=/etc/prometheus/prometheus.yml
    # 確保 Prometheus 在我們的服務啟動後再啟動，以避免初始的服務發現失敗
    depends_on:
      gateway-service:
        condition: service_started
      beacon-service:
        condition: service_started
    restart: on-failure

  # =================================================================
  # == ADR-006: 部署 Grafana 戰情可視化中心 ==
  # =================================================================
  grafana:
    image: grafana/grafana:11.1.0 # 使用一個明確的版本
    container_name: grafana-dashboard
    ports:
      - "3000:3000"
    volumes:
      # 自動化配置數據源，實現「基礎設施即代碼」
      - ./config/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources
      # =================================================================
      # == ADR-009: [新增] 掛載儀表板供應鏈目錄 ==
      # =================================================================
      - ./config/grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards
    # ... depends_on, restart ...    # 確保 Grafana 在 Prometheus 準備就緒後再啟動
    depends_on:
      prometheus:
        condition: service_started
    restart: on-failure

  loki:
    image: grafana/loki:3.1.0
    container_name: loki-server
    ports:
      - "3100:3100"
    command: -config.file=/etc/loki/local-config.yaml
    restart: on-failure

  promtail:
    image: grafana/promtail:3.1.0
    container_name: promtail-agent
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./config/promtail/config.yml:/etc/promtail/config.yml
    # 我們，以 root 用戶的身份，來運行這位“情報收集官”，
    # 授予他，訪問 Docker“中央情報頻道”的、至高無上的權力。
    user: root
    command: -config.file=/etc/promtail/config.yml
    depends_on:
      - loki
    restart: on-failure

  # =================================================================
  # == ADR-008: 部署 Grafana Tempo 時空記憶體 ==
  # =================================================================
  tempo:
    image: grafana/tempo:2.4.1 # 使用一個明確的版本
    container_name: tempo-server
    command: ["-config.file=/etc/tempo.yaml"]
    volumes:
      - ./config/tempo/tempo.yaml:/etc/tempo.yaml
      # 為 Tempo 的本地存儲，創建一個持久化的數據卷
      - tempo-data:/tmp/tempo
    ports:
      - "3200:3200"  # Tempo UI / HTTP
      - "4317:4317"  # OTLP gRPC Receiver
    restart: on-failure

# 在文件末尾，定義持久化的數據卷
volumes:
  tempo-data: