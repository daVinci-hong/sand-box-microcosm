# ADR-003: 採用 JWT 進行無狀態認證與授權

**狀態：** 已接納 (Accepted)
**日期：** 【2025-09-06】

---

## 背景 (Context)

隨著「第二幕：零信任堡壘」的開啟，我們必須踐行「零信任」的核心原則：**永不信任，始終驗證 (Never Trust, Always Verify)**。

這意味著，任何進入我們系統邊界（即 API 網關）的請求，都必須攜帶一個可被驗證的、可靠的身份憑證。我們的架構需要一個標準化的、適合微服務環境的、無狀態的機制來處理身份認證與授權。

## 決策 (Decision)

我們決定採用 **JSON Web Tokens (JWT)** 作為我們系統中，客戶端與 API 網關之間傳遞身份信息的標準。

具體的實施策略如下：

1.  **認證流程：**
    *   客戶端（在此 POC 中，我們將使用 Postman 或類似工具模擬）在發起請求時，必須在 `Authorization` HTTP 頭中，以 `Bearer` 方案攜帶一個有效的 JWT。

2.  **網關職責：**
    *   `gateway-service` 將成為我們系統中**唯一負責驗證 JWT 的組件**。它將作為一個**「認證衛兵」**。
    *   網關將使用一個預先配置好的密鑰，來驗證 JWT 的簽名是否有效、是否未過期。
    *   對於無效的令牌，網關將直接拒絕請求（例如，返回 `401 Unauthorized`）。

3.  **下游傳播：**
    *   一旦 JWT 驗證通過，網關將從 JWT 的載荷 (Payload) 中提取關鍵的用戶信息（例如 `userId`, `roles`），並將這些信息**作為新的 HTTP 頭**，向下游的微服務（如 `beacon-service`）傳遞。

4.  **實現工具（第一階段）：**
    *   為了遵循「精要主義」與「最簡可行哲學」，在第二幕的初始階段，我們**暫不引入**一個完整的、獨立的身份提供者（IdP，如 Keycloak）。
    *   我們將在 `gateway-service` 中，直接使用一個成熟的 Java JWT 庫（例如 **JJWT**），來處理令牌的驗證。令牌的簽發，我們將通過一個臨時的、內部的端點或工具來手動生成。

## 理由 (Consequences)

### 積極方面：

*   **無狀態 (Stateless)：** JWT 是自包含的 (self-contained)。令牌本身就包含了所有驗證所需的信息。這意味著我們的網關無需維護任何服務器端的會話（Session），這對於微服務架構的**水平擴展**和**韌性**至關重要。
*   **解耦 (Decoupled)：** 下游服務（如 `beacon-service`）無需關心用戶是如何被認證的。它們只需要信任由網關附加的、標準化的 HTTP 頭即可。這極大地簡化了內部服務的複雜性，讓它們可以專注於核心業務邏輯。
*   **行業標準：** JWT (RFC 7519) 是一個廣泛採用的開放標準，擁有幾乎所有主流語言的成熟庫支持，這降低了我們的實現成本和風險。
*   **可演進性 (Evolvability)：** 這種架構具備極佳的演進能力。未來，如果我們決定引入一個像 Keycloak 這樣的專業 IdP，我們**只需要改造 `gateway-service`** 與 IdP 對接的部分即可。對於所有下游服務而言，它們所依賴的「由網關傳遞的 HTTP 頭」這一**核心契約 (Contract)** 保持不變。這完美地踐行了「無痛換心」的設計思想。

### 消極方面（權衡）：

*   **令牌吊銷的複雜性 (Revocation Complexity)：** 由於 JWT 的無狀態特性，一旦簽發，就很難在它過期前使其失效。雖然可以通過維護一個「黑名單」來解決，但這又會重新引入狀態。在我們 POC 的範圍內，我們接受這個權衡，並將通過設置**較短的令牌有效期**來緩解此問題。
*   **安全風險（若配置不當）：** JWT 的載荷是 Base64 編碼的，並非加密。因此，**絕不能**在其中存放任何敏感信息。我們必須依賴強大的簽名算法（如 HS256 或 RS256）和被嚴格保護的密鑰，來確保其不可篡改性。

---
**文件結束**